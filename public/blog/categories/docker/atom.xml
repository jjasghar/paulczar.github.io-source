<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | tech.paulcz.net]]></title>
  <link href="http://paulczar.github.com/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://paulczar.github.com/"/>
  <updated>2014-05-13T15:39:20-05:00</updated>
  <id>http://paulczar.github.com/</id>
  <author>
    <name><![CDATA[Paul Czarkowski]]></name>
    <email><![CDATA[username.taken@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EZBake - A new way to converge docker containers with chef]]></title>
    <link href="http://paulczar.github.com/2014/05/ezbake-a-new-way-to-converge-docker-containers-with-chef.html"/>
    <updated>2014-05-13T15:05:00-05:00</updated>
    <id>http://paulczar.github.com/2014/05/ezbake-a-new-way-to-converge-docker-containers-with-chef</id>
    <content type="html"><![CDATA[<p><code>EZ Bake</code> came from an idea I had while watching the <a href="https://twitter.com/hangops">HangOps</a> <a href="https://www.youtube.com/watch?v=clLFKIeSADo&amp;feature=youtu.be">episode 2014-04-11</a> in which they were talking about <code>Docker</code> and Config Management being complementary rather than adversary.</p>

<p>I have expermented with using <code>Chef</code> and <code>Docker</code> together in the <a href="/2013/09/creating-immutable-servers-with-chef-and-docker-dot-io.html">past</a> but wanted to tackle the problem from a slightly different angle.  I've recently been working on some PAAS stuff, both <a href="http://deis.io">Deis</a> and <a href="http://solum.io">Solum</a> these both utilize the tooling from <a href="https://github.com/flynn/flynn">Flynn</a> which builds heroku style <code>buildpacks</code> in <code>Docker</code>.</p>

<!--more-->


<p>EZ Bake takes chef recipes designed for <code>chef-solo</code> ( but could easily be extended to do the same for <code>chef-zero</code>, or <code>chef-client</code> with a server) in a tarball via <code>stdin</code> and converges a docker node using that recipe.</p>

<p>This methodology seems a little weird at first,  but it gives you the ability to ship your Chef cookbooks as self-contained tarballs, or even more interestingly use the <code>git archive</code> command from your git repository to do this automatically and then pipe that directly to the <code>docker run</code> command.</p>

<p>In order to recognize and run your cookbook ( or repo ) it needs to contain the following files: <code>Berksfile</code>, <code>solo.json</code>, <code>solo.rb</code> in the root of your cookbook.   There is some provision for providing different locations for these via environment variables.   This is pre-ChefDK and will probably become easier with ChefDK.</p>

<p>I have provided an example in the ezbake repo that will install Java7 in the container.</p>

<p>This example shows:</p>

<ul>
<li>Converging a container using a local chef recipe</li>
<li>Committing the container to an image on completion</li>
<li>Removing the build container</li>
<li>Running the new image</li>
</ul>


<p>```
$ git clone paulczar/ezbake
$ cd ezbake/examples
$ ID=$(tar cf - . | sudo docker run -i -a stdin paulczar/ezbake) \
  &amp;&amp; sudo docker attach $ID \
  &amp;&amp; sudo docker commit $ID java7
  &amp;&amp; sudo docker rm $ID</p>

<p>Running Berkshelf to collect your cookbooks:
Installing java (1.22.0) from site: 'http://cookbooks.opscode.com/api/v1/cookbooks'
Converging your container:
[2014-04-12T22:10:24+00:00] INFO: Forking chef instance to converge...
....
[2014-04-12T22:16:52+00:00] INFO: Chef Run complete in 154.563192281 seconds
[2014-04-12T22:16:52+00:00] INFO: Running report handlers
[2014-04-12T22:16:52+00:00] INFO: Report handlers complete</p>

<p>$ sudo docker run -t java7 java -version
java version "1.7.0_51"
Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)</p>

<p>```</p>

<p>This could easily be built into a CI pipeline.   a git webhook could call jenkins which would clone the repo and then use a command like  <code>git archive master | docker run -i -a stdin paulczar/ezbake</code> to converge a container from it.</p>

<p>It could also very easily be used in <code>Deis</code> or <code>Solum</code> as an alternative to a Heroku buildpack.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running DEIS.IO on Rackspace Cloud]]></title>
    <link href="http://paulczar.github.com/2014/02/running-deis-io-on-rackspace-cloud.html"/>
    <updated>2014-02-23T11:45:00-06:00</updated>
    <id>http://paulczar.github.com/2014/02/running-deis-io-on-rackspace-cloud</id>
    <content type="html"><![CDATA[<p>I recently did a presentation at the Cloud Austin meetup titled <a href="http://tech.paulcz.net/presentation-cloud-austin-deis/#/">Docking with Unicorns</a> about new PAAS on the block <a href="http://deis.io">DEIS</a>.   Building out DEIS is quite easy,  make more easy by some tight integration they have with Rackspace Cloud.    If you're interested in what deis is go through my slides linked above, and the documentation on their website.    If you want to build out an environment to kick the tires a bit,  then click 'Read on' below and follow me down the rabbit hole.</p>

<!--more-->


<h2>Chef setup</h2>

<p>Chef offers a free hosted service for up to five servers.  That's plenty for this exercise so go to the <a href="https://www.getchef.com/account">registration page</a> and create yourself a user.  At some point it will prompt you to generate and save a key, do that and download it.</p>

<p>Once you have signed up you can download a knife config file and generate a validation key from the <a href="https://manage.opscode.com/organizations">Organizations</a> page.  We can save those down and then move them to a local working directory.</p>

<p><img src="https://lh5.googleusercontent.com/-3R-Z-bRi_s0/UwpipiLhhWI/AAAAAAAAN0Q/W6q_Rb7NFy8/w1240-h663-no/opscode-org-page.png" alt="chef org setup" /></p>

<h3>Prepare Working Environment</h3>

<p>Create a <code>~/paas</code> working directory and configure your local chef tools like this ( change the Download location to match the files you downloaded above ) :</p>

<p>```
$ mkdir -p ~/paas/.chef
$ cd ~/paas
$ mv ~/Downloads/<username>.pem .chef/
$ mv ~/Downloads/knife.rb .chef/
$ mv ~/Downloads/<username>-validator.pem .chef/</p>

<p>```</p>

<h3>Clone the Deis Repository</h3>

<p>Clone the deis project into your paas working directory:</p>

<p>```
$ cd ~/paas
$ git clone https://github.com/opdemand/deis.git
Cloning into 'deis'...
remote: Reusing existing pack: 5651, done.
Receiving objects: 100% (5651/5651), 2.16 MiB | 1.37 MiB/s, done.
remote: Total 5651 (delta 0), reused 0 (delta 0)
Resolving deltas: 100% (3131/3131), done.
Checking connectivity... done</p>

<p>```</p>

<h3>Install Pre-reqs</h3>

<p>Assuming you have a working <code>Ruby 1.9.3+</code> and the <code>bundler</code> gem installed you should be able to use the <code>Gemfile</code> from the deis project to ensure you have all the necessary tools:</p>

<p><code>
$ cd ~/paas/deis
$ bundle install
bundle install
Fetching gem metadata from https://rubygems.org/.......
Fetching additional metadata from https://rubygems.org/..
Using i18n (0.6.9)
Using multi_json (1.8.4)
Using activesupport (3.2.16)
Using addressable (2.3.5)
...
Using bundler (1.5.2)
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
</code></p>

<p><em>I had some errors installing the eventmachine gem and had to follow <a href="https://github.com/gitlabhq/gitlabhq/issues/1051#issuecomment-9176547">this fix</a> to get bundle install to work</em></p>

<h3>Test Chef Connectivity</h3>

<p>To make sure we configured chef correctly and installed knife as part of the bundle we can run a quick knife command:</p>

<p><code>
$ bundle exec knife client list
&lt;USERNAME&gt;-validator
</code></p>

<h3>Create an Environment for Deis</h3>

<p>Deis is currently hardcoded to use the <code>_default</code> chef environment.    There is a current <a href="https://github.com/opdemand/deis/issues/523">issue</a> on their github to resolve this.   Once that is done I'll update these instructions to create a <code>deis</code> environment.</p>

<h3>Upload the Deis Cookbooks</h3>

<p>If that went well we can upload our cookbooks:</p>

<p><code>
cd ~/paas/deis
$ bundle exec berks install
Installing apt (2.3.8) from site: 'http://cookbooks.opscode.com/api/v1/cookbooks'
Installing docker (0.31.0) from site: 'http://cookbooks.opscode.com/api/v1/cookbooks'
Installing rsyslog (1.10.2) from site: 'http://cookbooks.opscode.com/api/v1/cookbooks'
Installing sudo (2.3.0) from site: 'http://cookbooks.opscode.com/api/v1/cookbooks'
...
$ bundle exec berks upload
Using apt (2.3.8)
Using docker (0.31.0)
Using rsyslog (1.10.2)
Using sudo (2.3.0)
Installing deis (0.5.1) from git: 'https://github.com/opdemand/deis-cookbook.git' with branch: 'master' at ref: '6361706a1d3245d2a061ed55f5dd4b7cb60d5e5c'
Using git (2.7.0)
...
</code></p>

<h3>Create Deis Databags</h3>

<p>Deis uses some databags to help manage application state.  We can create them like this:</p>

<p><code>
$ bundle exec knife data bag create deis-formations
Created data_bag[deis-formations]
$ bundle exec knife data bag create deis-apps
Created data_bag[deis-apps]
</code></p>

<h2>Prepare Infrastructure</h2>

<p>I'm using Rackspace cloud servers for this as I have the (http://developer.rackspace.com/blog/developer-love-welcome-to-the-rackspace-cloud-developer-discount.html)[Rackspace Developer Discount] which is enough discount to host this for free.</p>

<p>Since Deis will want your rackspace credentials to configure worker nodes I recomment creating a user under (https://mycloud.rackspace.com/account#users/create)[User Management] in your account to use for this.</p>

<h3>Create a Cloud Load Balancer</h3>

<p>Log into mycloud.rackspace.com and click on the (https://mycloud.rackspace.com/load_balancers)[Load Balancers] button.  Select the Dallas Region (DFW) and hit <code>Create Load Balancer</code>.</p>

<ul>
<li>Set the Name to <code>deis</code> and check the region is set to <code>Dallas (DFW)</code> and hit <code>Create Load Balancer</code></li>
</ul>


<p><img src="https://lh4.googleusercontent.com/-E4cZvoKWlYU/Uwpiqr9xOKI/AAAAAAAAN0o/P3vGqPC8A98/w793-h592-no/rackspace-create-lb.png" alt="creating load balancer" /></p>

<ul>
<li>Take note of the public IP of the Load Balancer, we'll need it later.</li>
</ul>


<p><img src="https://lh4.googleusercontent.com/-ORvf6nzEduU/Uwpiqk5eP0I/AAAAAAAAN0k/WZ-NaJn3eJg/w770-h567-no/rackspace-lb.png" alt="load balancer created" /></p>

<h3>Wildcard DNS</h3>

<p>Deis' proxy layer requires you to set up Wildcard DNS to point to your proxy layer.  There are many ways to achieve this here are two options:</p>

<ol>
<li><p>Rackspace Cloud DNS can host wildcard DNS entries, if you already have DNS hosted by rackspace using Cloud DNS simply add an A record for <code>*.deis</code> under your domain and point it to the IP of your load balancer.</p></li>
<li><p>The (http://xip.io)[xip.io] domain does wildcard DNS based on your IP.  We can use this with our Cloud Load Balancer to load balance our applications.   My Load Balancer has a public IP of <code>50.56.167.26</code> therefore my wildcard domain will be <code>50.56.167.26.xip.io</code>.   Remember this.</p></li>
</ol>


<h3>Configure Knife for Rackspace</h3>

<p>The bundle install above already installed the rackspace knife plugin so we just need to add some details to <code>.chef/knife.rb</code>.</p>

<p><code>
$ cat &lt;&lt;'EOF' &gt;&gt; $HOME/.chef/knife.rb
knife[:rackspace_api_username] = "#{ENV['OS_USERNAME']}"
knife[:rackspace_api_key]      = "#{ENV['OS_PASSWORD']}"
knife[:rackspace_version]      = 'v2'
knife[:rackspace_region]       = :dfw
EOF
</code></p>

<h3>Install Rackspace Nova Client</h3>

<p>We also need the Nova client:</p>

<p><code>
$ sudo pip install rackspace-novaclient
$ cat &lt;&lt;'EOF' &gt;&gt; ~/paas/.chef/openrc
export OS_AUTH_URL=https://identity.api.rackspacecloud.com/v2.0/
export OS_AUTH_SYSTEM=rackspace
export OS_REGION_NAME=DFW
export OS_USERNAME=&lt;RACKSPACE_USERNAME&gt;
export NOVA_RAX_AUTH=1
export OS_PASSWORD=&lt;RACKSPACE_API_KEY&gt;
export OS_NO_CACHE=1
export OS_TENANT_NAME=&lt;RACKSPACE_USERNAME&gt;
EOF
$ source ~/paas/.chef/openrc
</code></p>

<h3>Test Rackspace Connectivity</h3>

<p>Make sure you can connect to Rackspace with Knife:</p>

<p><code>
$ bundle exec knife rackspace server list
Instance ID  Name  Public IP  Private IP  Flavor  Image  State
</code></p>

<p>Make sure you can connect to Rackspace with nova:</p>

<p><code>
$ nova list
+--------------------------------------+-----------------+--------+------------+-------------+----------------------------------------------------------------------------------------+
| ID                                   | Name            | Status | Task State | Power State | Networks                                                                               |
+--------------------------------------+-----------------+--------+------------+-------------+----------------------------------------------------------------------------------------+
</code></p>

<h2>Build base images for Controller and Nodes.</h2>

<p>This isn't strictly necessary,  but will help build your nodes quicker on subsequent builds.</p>

<h3>Launce a new instance:</h3>

<p>If we create a base image and pre-install some software we'll get a faster booting system for auto-provisioning:</p>

<p><code>
$ bundle exec knife rackspace server create \
  --image '80fbcb55-b206-41f9-9bc2-2dd7aac6c061' \
  --node-name 'deis-base-image' \
  --flavor 'performance1-1'
...
...
Instance ID: 56760bf1-b977-405e-9348-f70b15a14b87
Host ID: 97da00a12312a7e455bda70c6dfab8833953e2a03b081aeedfd68152
Name: deis-base-image
Flavor: 1 GB Performance
Image: Ubuntu 12.04
Metadata: []
Public DNS Name: 23-253-69-98.xip.io
Public IP Address: 23.253.69.98
Private IP Address: 10.208.101.31
Password: **************
</code></p>

<p>Take note of the <code>Instance ID</code>, <code>Public IP Address</code> and <code>Password</code>.  We'll need them later.</p>

<h3>Add users / keys to instance</h3>

<p>We're going to add our ssh key as well as a local <code>deis-ops</code> user to the image to make it easier to manage and troubleshoot later:</p>

<p>```
$ DEIS_IP=<IP_OF_SERVER>
$ ssh-copy-id root@$DEIS_IP
root@162.242.144.193's password:
Number of key(s) added: 1
Now try logging into the machine, with:   "ssh 'root@162.242.144.193'"
and check to make sure that only the key(s) you wanted were added.
$ ssh root@$DEIS_IP
Welcome to Ubuntu 12.04.3 LTS (GNU/Linux 3.2.0-55-virtual x86_64)</p>

<ul>
<li>Documentation:  https://help.ubuntu.com/</li>
</ul>


<p>  System information as of Sun Feb 23 18:34:40 UTC 2014</p>

<p>  System load:  0.08              Processes:           60
  Usage of /:   5.5% of 19.68GB   Users logged in:     0
  Memory usage: 6%                IP address for eth0: 162.242.144.193
  Swap usage:   0%                IP address for eth1: 10.208.135.114</p>

<p>  Graph this data and manage this system at https://landscape.canonical.com/</p>

<p>Last login: Sun Feb 23 18:33:02 2014 from cpe-24-27-47-27.austin.res.rr.com
root@deis-base-image:~# useradd --comment 'deis ops user' --home-dir '/home/deis-ops' \
  --shell '/bin/bash' --create-home deis-ops
root@deis-base-image:~# mkdir -p /home/deis-ops/.ssh &amp;&amp; \
   cp /root/.ssh/authorized_keys /home/deis-ops/.ssh/authorized_keys &amp;&amp; \
  chown -R deis-ops:deis-ops /home/deis-ops &amp;&amp; \
  chmod 0700 /home/deis-ops/.ssh &amp;&amp; \
  chmod 0600 /home/deis-ops/.ssh/authorized_keys &amp;&amp; \
  echo 'deis-ops ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/deis-ops &amp;&amp; \
  chmod 0440 /etc/sudoers.d/deis-ops
root@deis-base-image:~# exit
```</p>

<p>Check that you can log in with these new creds:</p>

<p><code>
$ ssh deis-ops@$DEIS_IP
deis$ sudo bash
root@deis$ exit
deis$ exit
</code></p>

<h3>Finish preparing node image</h3>

<p>Next we're going to update the kernel and prepare the base node image.</p>

<p><code>
$ ssh deis-ops@$DEIS_IP 'sudo apt-get update'
$ scp contrib/rackspace/*.sh deis-ops@$DEIS_IP:~/
$ ssh deis-ops@$DEIS_IP 'sudo ~/prepare-node-image.sh'
$ ssh deis-ops@$DEIS_IP 'sudo apt-get install -yq linux-image-generic-lts-raring linux-headers-generic-lts-raring'
</code></p>

<h3>Create an image from this server</h3>

<p><code>
$ nova image-create deis-base-image deis-node-image
</code></p>

<p>After a few minutes you should see this response to running <code>nova image-list</code>, if you're impatient like me wrap your command with a <code>watch</code>:</p>

<p>```
$ watch 'nova image-list | grep deis'
| df958d26-6515-4dd9-a449-920e74ea93a2 | deis-base-image                                              | ACTIVE | 0fc7f68b-176d-49a9-82ff-2d5893d32acd |</p>

<p>```</p>

<p>Once the image is active we can move onto the next steps.</p>

<h3>Prepare controller image</h3>

<p>Next we want to prepare the VM for the controller image:</p>

<p><code>
$ ssh deis-ops@$DEIS_IP 'sudo ~/prepare-controller-image.sh'
$ ssh deis-ops@$DEIS_IP 'sudo apt-get install -yq linux-image-generic-lts-raring linux-headers-generic-lts-raring'
</code></p>

<h3>Create an image from this server</h3>

<p><code>
$ nova image-create deis-base-image deis-base-image
</code></p>

<p>After a few minutes you should see this response to running <code>nova image-list</code>, if you're impatient like me wrap your command with a <code>watch</code>:</p>

<p>```
$ watch 'nova image-list | grep deis-node'
| f2236fa6-1e2d-4746-ac87-a3dd6b2de811 | deis-node-image                                              | ACTIVE | 633d5d88-54b3-463c-80fe-c119f4eb33a3 |</p>

<p>```</p>

<h3>Delete the instance</h3>

<p>No need to keep the instance around and keep paying for it once you have the image:</p>

<p><code>
$ bundle exec knife rackspace server list | grep deis  
42899699-68e7-4785-9f49-e0050f86249a  deis-base-image  162.242.144.193  10.208.135.114  performance1-1  80fbcb55-b206-41f9-9bc2-2dd7aac6c061  active
$ bundle exec knife rackspace server delete 42899699-68e7-4785-9f49-e0050f86249a --purge
</code></p>

<h2>Create the Deis Controller server</h2>

<h3>Launch the Server</h3>

<p>Launch the server from the image you created earlier:</p>

<p><code>
$ nova image-list | grep  deis-base-image
| a58c9895-6349-442a-bba7-99611900209d | deis-base-image
$ knife rackspace server create \
  --image a58c9895-6349-442a-bba7-99611900209d \
  --rackspace-metadata "{\"Name\": \"deis-controller\"}" \
  --rackspace-disk-config MANUAL \
  --server-name deis-controller \
  --node-name deis-controller \
  --flavor 'performance1-2'
Instance ID: bb713170-9322-424a-8837-863a4b396705
Name: deis-controller
Flavor: 2 GB Performance
Image: deis-base-image
...
Public IP Address: 23.253.104.13
Private IP Address: 10.208.132.190
Password: CQwDU4m97nvF
</code></p>

<p>Take note of the <code>Instance ID</code> and <code>Public IP Address</code>.</p>

<p>If you have an easy to manage domain add an A record for <code>deis</code> to it for the Public IP address.  If not
add an entry to your hosts file ( or do both! I did ):</p>

<p><code>
$ sudo sh -c "echo '&lt;IP_OF_SERVER&gt; deis' &gt;&gt; /etc/hosts"
</code></p>

<h3>Modify Chef Admin Group</h3>

<p>On the Chef management website click (https://manage.opscode.com/groups/admins/edit)[Groups] and add the <code>deis-controller</code> client and your validator client to the <code>admins</code> group.</p>

<p><img src="https://lh5.googleusercontent.com/-oSqB1Tdnn4c/UwpioPAXpJI/AAAAAAAANz4/xa8BdmRuTzQ/w579-h580-no/chef-admins.png" alt="chef admins group" /></p>

<h3>Converge the Deis Controller Server</h3>

<p>Edit the <code>deis-controller</code> node via this command:</p>

<p><code>
$ EDITOR=vi knife node edit deis-controller
</code></p>

<p>make it look like this:</p>

<p>```
{
  "name": "deis-controller",
  "chef_environment": "_default",
  "normal": {</p>

<pre><code>"tags": [

]
</code></pre>

<p>  },
  "run_list": [</p>

<pre><code>"recipe[deis::controller]"
</code></pre>

<p>  ]
}</p>

<p>```</p>

<p>then converge the node by running chef client on it:</p>

<p><code>
$ ssh deis-ops@deis sudo chef-client
[2014-02-23T19:25:32+00:00] INFO: Forking chef instance to converge...
[2014-02-23T19:25:32+00:00] INFO: *** Chef 11.6.2 ***
[2014-02-23T19:25:33+00:00] INFO: Run List is [recipe[deis::controller]]
[2014-02-23T19:25:33+00:00] INFO: Run List expands to [deis::controller]
[2014-02-23T19:25:33+00:00] INFO: Starting Chef Run for deis-controller
[2014-02-23T19:25:33+00:00] INFO: Running start handlers
[2014-02-23T19:25:33+00:00] INFO: Start handlers complete.
...
$
</code></p>

<h2>Testing Deis</h2>

<h3>Install the Deis Client with pip</h3>

<p>The Deis client is written in python and can be installed by <code>pip</code>:</p>

<p><code>
$ sudo pip install deis  
</code></p>

<h3>Register Admin User</h3>

<p>First user to register becomes the Admin:</p>

<p><code>
$ deis register http://deis:8000
username: admin
password:
password (confirm):
email: admin@example.com
Registered admin
Logged in as admin
</code></p>

<p>Push your public key to deis:</p>

<p><code>
$ deis keys:add ~/.ssh/id_rsa.pub
Uploading SSH_KEY to Deis...done
</code></p>

<p>check the web server is serving content by browsing to (http://deis)[http://deis] and entering your admin credentials.</p>

<h3>Teach Deis your provider credentials</h3>

<p>Deis will automatically provision worker nodes if you teach it your credentials.</p>

<p>We already have our Rackspace credentials saved to <code>~/paas/.chef/openrc</code> but Deis wants them named differently:</p>

<p><code>
$ export RACKSPACE_USERNAME=$OS_USERNAME
$ export RACKSPACE_API_KEY=$OS_PASSWORD
$ deis providers:discover
No EC2 credentials discovered.
Discovered Rackspace credentials: ****************
Import Rackspace credentials? (y/n) : y
Uploading Rackspace credentials... done
No DigitalOcean credentials discovered.
No Vagrant VMs discovered.
</code></p>

<h2>Deploy Formations &amp; Layers</h2>

<h3>Formation</h3>

<p>Formations are collections of infrastructure for serving applications.   We'll call our first Formation <code>dev</code> for development.</p>

<p>Create formation (using the wildcard domain from our cloud load balancer created earlier in the <code>--domain</code> argument):</p>

<p><code>
$ deis formations:create dev --domain=50.56.167.26.xip.io
Creating formation... done, created dev
See `deis help layers:create` to begin building your formation
</code></p>

<h3>Layers</h3>

<p>Layers are a heterogenerous collection of nodes that perform one of two function:</p>

<ol>
<li>Proxy - Directs traffic to the appropriate container running the application.</li>
<li>Runtime - Runs the containers that hold the applications.</li>
</ol>


<p>We're going to create a layer called <code>nodes</code> that will perform both the proxy and runtime functions:</p>

<p><code>
$ deis layers:create dev nodes rackspace-dfw --proxy=y --runtime=y
Creating nodes layer... done in 4s
</code></p>

<p><em>note</em> There's currently a <a href="https://github.com/opdemand/deis/issues/541">bug</a> that causes the first creation of a layer to fail.  if that happens run the following:</p>

<p>```
deis formations:create dev --domain=50.56.167.26.xip.io
Creating formation... done, created dev</p>

<p>See <code>deis help layers:create</code> to begin building your formation
$ deis layers:create dev nodes rackspace-dfw --proxy=y --runtime=y
Creating nodes layer... 500 INTERNAL SERVER ERROR</p>

<h1>Server Error (500)</h1>


<p>$ deis layers:destroy dev nodes
Destroying nodes layer... done in 0s
$ deis layers:create dev nodes rackspace-dfw --proxy=y --runtime=y
Creating nodes layer... done in 2s</p>

<p>```</p>

<h3>Build Nodes</h3>

<p>Next we tell deis to spin up two Cloud Servers which will become members of the <code>nodes</code> layer.</p>

<p><code>
$ deis nodes:scale dev nodes=2
Scaling nodes... but first, coffee!
done in 345s
Use `deis create --formation=dev` to create an application
</code></p>

<p>This can sometimes take longer than the <code>deis</code> cli timeout.   Don't fear,  just wait a bit longer, this could be a great time to explore the <code>deis</code> cli by running <code>deis help</code>.</p>

<h2>Update Cloud Load Balancer</h2>

<p>Add these two nodes to the (https://mycloud.rackspace.com/load_balancers)[Cloud Load Balancer] we created earlier.</p>

<p><img src="https://lh6.googleusercontent.com/-yaJfxoyDk4M/UwpioEndiOI/AAAAAAAANz0/aXannmisdbE/w903-h407-no/cloud-servers-list.png" alt="cloud server list" /></p>

<p>This is simple to do through the GUI:</p>

<ul>
<li>Click on your load balancer and under <code>Nodes</code> click the <code>Add Cloud Servers</code> button.</li>
<li>Check the box beside the two <code>dev-nodes</code> servers and click <code>Add Selected Servers</code>.</li>
</ul>


<p><img src="https://lh6.googleusercontent.com/-zm6sB7l7YVk/Uwpin4BNJPI/AAAAAAAANzw/b-_J2ieyIuE/w773-h476-no/cloud-lb-nodes.png" alt="cloud lb servers" /></p>

<h2>Deploy an Application</h2>

<p>So great, you have a PaaS, but what do you do now?  Deploy some apps of course!</p>

<h3>NodeJS Example App</h3>

<p>Download the NodeJS example application so like:</p>

<p><code>
$ mkdir -p ~/paas/apps
$ cd ~paas/apps
$ git clone https://github.com/opdemand/example-nodejs-express.git
$ cd example-nodejs-express
</code></p>

<h3>Create an Application in Deis</h3>

<p>Use the Deis command line tool to create a new application:</p>

<p><code>
$ deis create      
Creating application... done, created exotic-sandwich
Git remote deis added
</code></p>

<h3>Push your Application to Deis</h3>

<p>This will push, deploy and Launch the app.  The first one will take some time as deis has to download some docker images,  subsequent apps will be much faster:</p>

<p>```
$ git push deis master                   <br/>
git push deis master
Counting objects: 184, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (89/89), done.
Writing objects: 100% (184/184), 28.77 KiB | 0 bytes/s, done.
Total 184 (delta 103), reused 165 (delta 92)
-----> Node.js app detected
-----> Requested node range: 0.10.x
-----> Resolved node version: 0.10.26
-----> Downloading and installing node
-----> Installing dependencies</p>

<pre><code>   npm WARN package.json example-nodejs-express@0.0.1 No repository field.
   npm http GET https://registry.npmjs.org/express
   npm http 200 https://registry.npmjs.org/express
</code></pre>

<p>...
-----> Caching node_modules directory for future builds
-----> Cleaning up node-gyp and npm artifacts
-----> Building runtime environment
-----> Discovering process types</p>

<pre><code>   Procfile declares types -&gt; web
</code></pre>

<p>-----> Compiled slug size is 5.5M
-----> Building Docker image
Uploading context 5.698 MB
Uploading context
Step 0 : FROM deis/slugrunner
 ---> bb0a27915014
Step 1 : RUN mkdir -p /app
 ---> Running in 1ae5cdeaad9a
 ---> 6e6467466d48
Step 2 : ADD slug.tgz /app
 ---> 191a4345b1e4
Step 3 : ENTRYPOINT ["/runner/init"]
 ---> Running in d322512d5865
 ---> 2866cf3e37c9
Successfully built 2866cf3e37c9
-----> Pushing image to private registry</p>

<pre><code>   Launching... done, v2
</code></pre>

<p>-----> exotic-sandwich deployed to Deis</p>

<pre><code>   http://exotic-sandwich.50.56.167.26.xip.io

   To learn more, use `deis help` or visit http://deis.io
</code></pre>

<p>To ssh://git@deis:2222/exotic-sandwich.git
 * [new branch]      master -> master</p>

<p>```</p>

<h2>Did it work ?</h2>

<p>Open your web browser to the URL in the output of the previous command.  In my case this was <code>http://exotic-sandwich.50.56.167.26.xip.io</code>.</p>

<p>If everything worked the text in the browser window should read <code>Powered by Deis</code>.</p>

<p><img src="https://lh6.googleusercontent.com/-cxuysxM_oM8/UwpipfiKFMI/AAAAAAAAN0U/M7T9dC6xJ-E/w446-h171-no/deis-app-1.png" alt="deis app" /></p>

<h2>Configure and Scale your application</h2>

<p>We can set config parameters for our apps by running <code>deis config</code>.   The example app we're using has a config paramater 'POWERED_BY' so we can set that by running:</p>

<p><code>
$ deis config:set POWERED_BY='DEIS and Rackspace'
=== exotic-sandwich
POWERED_BY: DEIS and Rackspace
</code></p>

<p><img src="https://lh6.googleusercontent.com/-J5AcNytZLOQ/UwpipEdpeBI/AAAAAAAAN0E/WXWC08rxsBU/w507-h157-no/deis-app-2.png" alt="deis app2" /></p>

<p>Expecting visitors?  Let's scale your app to 5 nodes:</p>

<p>```
$ deis scale web=5
Scaling containers... but first, coffee!
done in 54s</p>

<p>=== exotic-sandwich Containers</p>

<p>--- web: <code>node server.js</code>
web.1 up 2014-02-23T20:22:07.241Z (dev-nodes-2)
web.2 up 2014-02-23T20:28:21.778Z (dev-nodes-1)
web.3 up 2014-02-23T20:28:21.788Z (dev-nodes-2)
web.4 up 2014-02-23T20:28:21.799Z (dev-nodes-1)
web.5 up 2014-02-23T20:28:21.810Z (dev-nodes-2)
```</p>

<p>You can see what your app is doing by running <code>deis info</code> and <code>deis logs</code>:</p>

<p>```
$ deis info
=== exotic-sandwich Application
{
  "updated": "2014-02-23T20:28:21.812Z",
  "uuid": "ef618db6-f5a8-4cab-a7d9-d01e78036e3a",
  "created": "2014-02-23T20:16:51.931Z",
  "formation": "dev",
  "owner": "admin",
  "id": "exotic-sandwich",
  "containers": "{\"web\": 5}"
}</p>

<p>=== exotic-sandwich Containers</p>

<p>--- web: <code>node server.js</code>
web.1 up 2014-02-23T20:22:07.241Z (dev-nodes-2)
web.2 up 2014-02-23T20:28:21.778Z (dev-nodes-1)
web.3 up 2014-02-23T20:28:21.788Z (dev-nodes-2)
web.4 up 2014-02-23T20:28:21.799Z (dev-nodes-1)
web.5 up 2014-02-23T20:28:21.810Z (dev-nodes-2)
```</p>

<p><code>
$ deis logs
Feb 23 20:22:57 dev-nodes exotic-sandwich[web.1]: Server listening on port 10001 in development mode
Feb 23 20:25:38 dev-nodes exotic-sandwich[web.1]: Server listening on port 10001 in development mode
Feb 23 20:26:49 dev-nodes exotic-sandwich[web.1]: Server listening on port 10001 in development mode
Feb 23 20:28:28 dev-nodes exotic-sandwich[web.3]: Server listening on port 10003 in development mode
Feb 23 20:28:29 dev-nodes exotic-sandwich[web.5]: Server listening on port 10005 in development mode
Feb 23 20:29:11 dev-nodes exotic-sandwich[web.2]: Server listening on port 10002 in development mode
Feb 23 20:29:12 dev-nodes exotic-sandwich[web.4]: Server listening on port 10004 in development mode
</code></p>

<p>Congratulations!  You've successfully built out your own cost effective PAAS and deployed your first application to it.</p>

<p>Speaking of costs ...  How much would this cost to run per month ?</p>

<ul>
<li>Cloud Load Balancer - $10.95 / month</li>
<li>Deis Controller - $57.60 / month</li>
<li>Deis Nodes (x2) - $115.20 / month</li>
</ul>


<p>Total:  $183.75 / month.</p>

<p>You could run all of this on a single server without a load balancer,  which means it would be just $57.60/month, which with the <a href="http://developer.rackspace.com/devtrial/">Rackspace Developer Discount</a> would reduce down to just $7.60/month.</p>

<h1>Epilogue</h1>

<h2>Cleanup</h2>

<p>Destroy your app:</p>

<p>```
$ deis destroy</p>

<p> !    WARNING: Potentially Destructive Action
 !    This command will destroy the application: exotic-sandwich
 !    To proceed, type "exotic-sandwich" or re-run this command with --confirm=exotic-sandwich</p>

<blockquote><p>exotic-sandwich
Destroying exotic-sandwich... done in 21s
Git remote deis removed
```</p></blockquote>

<p>list your servers:</p>

<p><code>
$ bundle exec knife rackspace server list
Instance ID                           Name             Public IP       Private IP      Flavor          Image                                 State
7c43ecb9-1ba3-454c-a5f4-637b56961d68  dev-nodes        23.253.102.184  10.208.135.137  performance1-2  2d59cbce-92fa-412b-8a5e-6eb426ce7dc9  active
f89c4b25-6486-422a-907a-16b3b3223a5e  dev-nodes        23.253.102.158  10.208.137.18   performance1-2  2d59cbce-92fa-412b-8a5e-6eb426ce7dc9  active
bb713170-9322-424a-8837-863a4b396705  deis-controller  23.253.104.13   10.208.132.190  performance1-2  a58c9895-6349-442a-bba7-99611900209d  active
</code></p>

<p>Delete your servers by running the following command for each:</p>

<p>```
$ bundle exec knife rackspace server delete 7c43ecb9-1ba3-454c-a5f4-637b56961d68 --purge
Instance ID: 7c43ecb9-1ba3-454c-a5f4-637b56961d68
Host ID: e0da0172f321babe99aec9686c7b99ac7fa5ff8fa1ada934f5fae842
Name: dev-nodes
Flavor: 2 GB Performance
Image: deis-node-image
Public IP Address: 23.253.102.184
Private IP Address: 10.208.135.137</p>

<p>Do you really want to delete this server? (Y/N) y
[WARNING] Error Parsing response json - Yajl::ParseError
WARNING: Deleted server 7c43ecb9-1ba3-454c-a5f4-637b56961d68
```</p>

<p>Clean up your chef:</p>

<p><code>
$ bundle exec knife data bag delete deis-apps
$ bundle exec knife data bag delete deis-formations
$ bundle exec knife client delete dev-nodes-1
$ bundle exec knife client delete dev-nodes-2
$ bundle exec knife node delete dev-nodes-1
$ bundle exec knife node delete dev-nodes-2
</code></p>

<p>Delete your glance images:</p>

<p><code>
$ nova image-delete deis-base-image
$ nova image-delete deis-node-image
</code></p>

<p>Finally delete your Cloud Load Balancer from the <a href="https://mycloud.rackspace.com/load_balancers">Rackspace UI</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing docker services with this one easy trick]]></title>
    <link href="http://paulczar.github.com/2013/10/managing-docker-services-with-this-one-easy-trick.html"/>
    <updated>2013-10-20T15:46:00-05:00</updated>
    <id>http://paulczar.github.com/2013/10/managing-docker-services-with-this-one-easy-trick</id>
    <content type="html"><![CDATA[<p>I have been having a lot of internal debate about the idea of running more than one service in a docker container.   A Docker container is built to run a single process in the foreground and to live for only as long as that process is running.  This is great in a utopian world where servers are immutable and sysadmins drink tiki drinks on the beach,  however it doesn't always translate well to the real world.</p>

<p>Examples where you might want to be able to run multiple servers span from the simple use case of running <code>sshd</code> as well as your application to running a web app such as <code>wordpress</code> where you might want both <code>apache</code> and <code>mysql</code> running in the same container.</p>

<p>Wrapping your applications in a supervisor daemon such as <code>runit</code> seems like a perfect fit for this.  All you need to do is install <code>runit</code> as part of your <code>dockerfile</code> and then create appropriate service directories for the apps you want to run in the container.    I was doing some testing of this when I realized a quirk of <code>runit</code> which I could exploit for evil.</p>

<p>To start or stop a service with <code>runit</code> is simply a matter of creating or deleting a symlink in a service directory,   so in theory if you could expose that directory to the server hosting the container you could exploit that to start and stop services from outside of the container.  <code>Docker</code> volume mapping allows exactly this!</p>

<p>Below you will find examples of running three services (logstash,elasticsearch,kibana) that make up the <code>logstash</code> suite.</p>

<!--more-->


<h2>Start by cloning the demo git repository and run demo.sh</h2>

<p><code>
$ git clone https://github.com/paulczar/docker-runit-demo.git
$ cd docker-runit-demo
$ ./demo.sh
</code></p>

<h3>demo.sh script</h3>

<h4>Step 1:  Build the container</h4>

<p>The script uses the below <code>Dockerfile</code> to build the base container that we'll be running.</p>

<p>```</p>

<h1>Installs runit for service management</h1>

<p>#</p>

<h1>Author: Paul Czarkowski</h1>

<h1>Date: 10/20/2013</h1>

<p>FROM paulczar/jre7
MAINTAINER Paul Czarkowski "paul@paulcz.net"</p>

<p>RUN apt-get update</p>

<p>RUN apt-get -y install curl wget git nginx
RUN apt-get -y install runit || echo</p>

<p>CMD ["/usr/sbin/runsvdir-start"]</p>

<p>```</p>

<h4>Step 2: Install the applications</h4>

<p>This will take a few minutes the first time as it needs to download <code>logstash</code>, <code>kibana</code>, and <code>elasticsearch</code> and stage them in a local <code>./opt</code>directory.</p>

<h4>Step 3: Start the Docker container</h4>

<p>Starts the <code>Docker</code> container with the following command:</p>

<p><code>
docker run -d -p 8080:80 -p 5014:514 -p 9200:9200 \
  -v $BASE/opt:/opt \
  -v $BASE/sv:/etc/sv \
  -v $BASE/init:/etc/init \
  -v $BASE/service:/etc/service \
  demo/runit
</code></p>

<p>The container should be up and running</p>

<p><code>
$ docker ps
ID                  IMAGE               COMMAND                CREATED             STATUS              PORTS
eb495ad92ba0        demo/runit:latest   /usr/sbin/runsvdir-s   4 seconds ago       Up 3 seconds        5014-&gt;514, 8080-&gt;80, 9200-&gt;9200   
</code></p>

<p>However there aren't any services running!</p>

<p><code>
$ curl localhost:8080
curl: (56) Recv failure: Connection reset by peer
$ curl localhost:9200
curl: (56) Recv failure: Connection reset by peer
</code></p>

<p>We can start the services with the following commands</p>

<p><code>
$ cd service
$ ln -s ../sv/elasticsearch
$ ln -s ../sv/logstash
$ ln -s ../sv/kibana
cd ..
</code></p>

<p>We can now see the services are running, test the ports and send some data to logstash.</p>

<p><code>
$ curl localhost:8080      
&lt;!DOCTYPE html&gt;&lt;!--[if IE 8]&gt;&lt;html class="no-js lt-ie9" lang="en"&gt;&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;
...
curl localhost:9200
{
  "ok" : true,
  "status" : 200,
...
$tail -100 /var/log/syslog | nc localhost 5014
</code></p>

<p>Stop a service ?</p>

<p><code>
$ rm service/elasticsearch
$ rm service/logstash
$ rm service/kibana
</code></p>

<h2>Bonus Round: Logs!</h2>

<p>The beautify of doing this is that we're actually logging the application output to a mounted volume.   This means we now have access to their logs from the host machine.</p>

<p><code>
$ tail opt/logstash/logs/current
$ tail opt/elasticsearch-0.90.5/logs/current
$ tail opt/kibana/logs/access.log
</code></p>

<h2>Cleanup</h2>

<p>Unfortunately any files created inside the docker instance are owned by root ( an artifact of docker daemon running as root ).   If you're in The following script will clean out any such files after you've stopped the docker container.</p>

<p>It will delete any files/dirs inside your current directory that are owned by root.  Obviously it can be very dangerous to run ... so be careful where you run it from!</p>

<p><code>
$ sudo find . -uid 0   -exec rm -rfv {} \;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating immutable servers with chef and docker.io]]></title>
    <link href="http://paulczar.github.com/2013/09/creating-immutable-servers-with-chef-and-docker-dot-io.html"/>
    <updated>2013-09-07T18:18:00-05:00</updated>
    <id>http://paulczar.github.com/2013/09/creating-immutable-servers-with-chef-and-docker-dot-io</id>
    <content type="html"><![CDATA[<p>Building applications in a <a href="http://docker.io">docker.io</a> Dockerfile is relatively simple,  but sometimes you want to just install the application exactly as you would normally via already built chef cookbooks.   Turns out this is actually pretty simple.</p>

<p>The first thing you'll need to do is build a container with chef-client and berkshelf installed.   You can grab the one I've built by running <code>docker pull paulczar/chef-solo</code> or build one youself from a <code>Dockerfile</code> that looks a little something like the following...</p>

<!--more-->


<h3>Creating a docker.io container with chef and berkshelf</h3>

<p>``` ruby Dockerfile</p>

<h1>DOCKER-VERSION 0.5.3</h1>

<p>FROM ubuntu:12.10
MAINTAINER Paul Czarkowski "paul@paulcz.net"</p>

<p>RUN apt-get -y update
RUN apt-get -y install curl build-essential libxml2-dev libxslt-dev git
RUN curl -L https://www.opscode.com/chef/install.sh | bash
RUN echo "gem: --no-ri --no-rdoc" > ~/.gemrc
RUN /opt/chef/embedded/bin/gem install berkshelf
```</p>

<p><em>you'll notice I'm using the embedded chef ruby to install the berkshelf gem,  this is a handy shortcut to avoid messing around with random ruby versions from your distributions packaging.</em></p>

<p>run <code>$ docker build -t paulczar/chef-solo .</code> to build a usable docker container from the above <code>Dockerfile</code>.</p>

<h3>Using chef-solo and berkshelf to build an application in a docker.io container</h3>

<p>My <a href="https://github.com/paulczar/docker-chef-solo">example application</a> will install <code>Kibana3</code> to your docker container.   I'll step through how it works below.</p>

<h4>Chef-Solo</h4>

<p>To run <code>chef-solo</code> successfully we require two files.   <code>solo.rb</code> to set up file locations, and `solo.json' to set up the json / run list required for your application.</p>

<p>``` ruby chef.rb
root = File.absolute_path(File.dirname(<strong>FILE</strong>))</p>

<p>file_cache_path root
cookbook_path root + '/cookbooks'
```</p>

<p>``` json chef.json
{
  "kibana": {</p>

<pre><code>"webserver_listen": "0.0.0.0"
</code></pre>

<p>  },
  "run_list": [</p>

<pre><code>"recipe[kibana::default]"
</code></pre>

<p>  ]
}
```</p>

<h4>Berkshelf</h4>

<p>To run <code>berkshelf</code> we need to build a Berksfile which contains a list of all the chef cookbooks required for the applocation.   Berkshelf will download these cookbooks to a local directory which will be usable by chef-solo.</p>

<p>``` ruby Berksfile
site :opscode</p>

<p>cookbook 'build-essential'
cookbook 'apache2'
cookbook 'git'
cookbook 'kibana', github: 'lusis/chef-kibana'
cookbook 'nginx' , github: 'opscode-cookbooks/nginx'
```</p>

<p><em>You can see some of the cookbooks are being pulled from the opscode repository,  whereas others are being pulled directly from github.</em></p>

<h4>Dockerfile</h4>

<p>All that's left now is to create a Dockerfile that will bring it all together.</p>

<p>``` ruby Dockerfile</p>

<h1>DOCKER-VERSION 0.5.3</h1>

<p>FROM paulczar/chef-client
MAINTAINER Paul Czarkowski "paul@paulcz.net"</p>

<p>RUN apt-get -y update
ADD . /chef
RUN cd /chef &amp;&amp; /opt/chef/embedded/bin/berks install --path /chef/cookbooks
RUN chef-solo -c /chef/solo.rb -j /chef/solo.json
RUN echo "daemon off;" >> /etc/nginx/nginx.conf</p>

<p>CMD ["nginx"]
```</p>

<p>Run <code>$ docker build -t demo/kibana3 .</code> to build your application.</p>

<p>It will add the local files ( <code>solo.rb</code>, <code>solo.json</code>, <code>Berksfile</code> ) to /chef in the server and then call berkshelf to download the cookbooks and chef-solo to install your application.   Finally it will give <code>nginx</code> a directive to run in the foreground so that we don't have to do any sneaky prcess control to get it to work with the way <code>docker.io</code> runs processes.</p>

<p>To run the resultant <code>docker.io</code> container you simply need to run <code>$ docker run -d -p 80 demo/kibana3</code></p>
]]></content>
  </entry>
  
</feed>
