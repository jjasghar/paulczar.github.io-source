<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: chef | tech.paulcz.net]]></title>
  <link href="http://paulczar.github.com/blog/categories/chef/atom.xml" rel="self"/>
  <link href="http://paulczar.github.com/"/>
  <updated>2014-05-13T15:39:20-05:00</updated>
  <id>http://paulczar.github.com/</id>
  <author>
    <name><![CDATA[Paul Czarkowski]]></name>
    <email><![CDATA[username.taken@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EZBake - A new way to converge docker containers with chef]]></title>
    <link href="http://paulczar.github.com/2014/05/ezbake-a-new-way-to-converge-docker-containers-with-chef.html"/>
    <updated>2014-05-13T15:05:00-05:00</updated>
    <id>http://paulczar.github.com/2014/05/ezbake-a-new-way-to-converge-docker-containers-with-chef</id>
    <content type="html"><![CDATA[<p><code>EZ Bake</code> came from an idea I had while watching the <a href="https://twitter.com/hangops">HangOps</a> <a href="https://www.youtube.com/watch?v=clLFKIeSADo&amp;feature=youtu.be">episode 2014-04-11</a> in which they were talking about <code>Docker</code> and Config Management being complementary rather than adversary.</p>

<p>I have expermented with using <code>Chef</code> and <code>Docker</code> together in the <a href="/2013/09/creating-immutable-servers-with-chef-and-docker-dot-io.html">past</a> but wanted to tackle the problem from a slightly different angle.  I've recently been working on some PAAS stuff, both <a href="http://deis.io">Deis</a> and <a href="http://solum.io">Solum</a> these both utilize the tooling from <a href="https://github.com/flynn/flynn">Flynn</a> which builds heroku style <code>buildpacks</code> in <code>Docker</code>.</p>

<!--more-->


<p>EZ Bake takes chef recipes designed for <code>chef-solo</code> ( but could easily be extended to do the same for <code>chef-zero</code>, or <code>chef-client</code> with a server) in a tarball via <code>stdin</code> and converges a docker node using that recipe.</p>

<p>This methodology seems a little weird at first,  but it gives you the ability to ship your Chef cookbooks as self-contained tarballs, or even more interestingly use the <code>git archive</code> command from your git repository to do this automatically and then pipe that directly to the <code>docker run</code> command.</p>

<p>In order to recognize and run your cookbook ( or repo ) it needs to contain the following files: <code>Berksfile</code>, <code>solo.json</code>, <code>solo.rb</code> in the root of your cookbook.   There is some provision for providing different locations for these via environment variables.   This is pre-ChefDK and will probably become easier with ChefDK.</p>

<p>I have provided an example in the ezbake repo that will install Java7 in the container.</p>

<p>This example shows:</p>

<ul>
<li>Converging a container using a local chef recipe</li>
<li>Committing the container to an image on completion</li>
<li>Removing the build container</li>
<li>Running the new image</li>
</ul>


<p>```
$ git clone paulczar/ezbake
$ cd ezbake/examples
$ ID=$(tar cf - . | sudo docker run -i -a stdin paulczar/ezbake) \
  &amp;&amp; sudo docker attach $ID \
  &amp;&amp; sudo docker commit $ID java7
  &amp;&amp; sudo docker rm $ID</p>

<p>Running Berkshelf to collect your cookbooks:
Installing java (1.22.0) from site: 'http://cookbooks.opscode.com/api/v1/cookbooks'
Converging your container:
[2014-04-12T22:10:24+00:00] INFO: Forking chef instance to converge...
....
[2014-04-12T22:16:52+00:00] INFO: Chef Run complete in 154.563192281 seconds
[2014-04-12T22:16:52+00:00] INFO: Running report handlers
[2014-04-12T22:16:52+00:00] INFO: Report handlers complete</p>

<p>$ sudo docker run -t java7 java -version
java version "1.7.0_51"
Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)</p>

<p>```</p>

<p>This could easily be built into a CI pipeline.   a git webhook could call jenkins which would clone the repo and then use a command like  <code>git archive master | docker run -i -a stdin paulczar/ezbake</code> to converge a container from it.</p>

<p>It could also very easily be used in <code>Deis</code> or <code>Solum</code> as an alternative to a Heroku buildpack.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating immutable servers with chef and docker.io]]></title>
    <link href="http://paulczar.github.com/2013/09/creating-immutable-servers-with-chef-and-docker-dot-io.html"/>
    <updated>2013-09-07T18:18:00-05:00</updated>
    <id>http://paulczar.github.com/2013/09/creating-immutable-servers-with-chef-and-docker-dot-io</id>
    <content type="html"><![CDATA[<p>Building applications in a <a href="http://docker.io">docker.io</a> Dockerfile is relatively simple,  but sometimes you want to just install the application exactly as you would normally via already built chef cookbooks.   Turns out this is actually pretty simple.</p>

<p>The first thing you'll need to do is build a container with chef-client and berkshelf installed.   You can grab the one I've built by running <code>docker pull paulczar/chef-solo</code> or build one youself from a <code>Dockerfile</code> that looks a little something like the following...</p>

<!--more-->


<h3>Creating a docker.io container with chef and berkshelf</h3>

<p>``` ruby Dockerfile</p>

<h1>DOCKER-VERSION 0.5.3</h1>

<p>FROM ubuntu:12.10
MAINTAINER Paul Czarkowski "paul@paulcz.net"</p>

<p>RUN apt-get -y update
RUN apt-get -y install curl build-essential libxml2-dev libxslt-dev git
RUN curl -L https://www.opscode.com/chef/install.sh | bash
RUN echo "gem: --no-ri --no-rdoc" > ~/.gemrc
RUN /opt/chef/embedded/bin/gem install berkshelf
```</p>

<p><em>you'll notice I'm using the embedded chef ruby to install the berkshelf gem,  this is a handy shortcut to avoid messing around with random ruby versions from your distributions packaging.</em></p>

<p>run <code>$ docker build -t paulczar/chef-solo .</code> to build a usable docker container from the above <code>Dockerfile</code>.</p>

<h3>Using chef-solo and berkshelf to build an application in a docker.io container</h3>

<p>My <a href="https://github.com/paulczar/docker-chef-solo">example application</a> will install <code>Kibana3</code> to your docker container.   I'll step through how it works below.</p>

<h4>Chef-Solo</h4>

<p>To run <code>chef-solo</code> successfully we require two files.   <code>solo.rb</code> to set up file locations, and `solo.json' to set up the json / run list required for your application.</p>

<p>``` ruby chef.rb
root = File.absolute_path(File.dirname(<strong>FILE</strong>))</p>

<p>file_cache_path root
cookbook_path root + '/cookbooks'
```</p>

<p>``` json chef.json
{
  "kibana": {</p>

<pre><code>"webserver_listen": "0.0.0.0"
</code></pre>

<p>  },
  "run_list": [</p>

<pre><code>"recipe[kibana::default]"
</code></pre>

<p>  ]
}
```</p>

<h4>Berkshelf</h4>

<p>To run <code>berkshelf</code> we need to build a Berksfile which contains a list of all the chef cookbooks required for the applocation.   Berkshelf will download these cookbooks to a local directory which will be usable by chef-solo.</p>

<p>``` ruby Berksfile
site :opscode</p>

<p>cookbook 'build-essential'
cookbook 'apache2'
cookbook 'git'
cookbook 'kibana', github: 'lusis/chef-kibana'
cookbook 'nginx' , github: 'opscode-cookbooks/nginx'
```</p>

<p><em>You can see some of the cookbooks are being pulled from the opscode repository,  whereas others are being pulled directly from github.</em></p>

<h4>Dockerfile</h4>

<p>All that's left now is to create a Dockerfile that will bring it all together.</p>

<p>``` ruby Dockerfile</p>

<h1>DOCKER-VERSION 0.5.3</h1>

<p>FROM paulczar/chef-client
MAINTAINER Paul Czarkowski "paul@paulcz.net"</p>

<p>RUN apt-get -y update
ADD . /chef
RUN cd /chef &amp;&amp; /opt/chef/embedded/bin/berks install --path /chef/cookbooks
RUN chef-solo -c /chef/solo.rb -j /chef/solo.json
RUN echo "daemon off;" >> /etc/nginx/nginx.conf</p>

<p>CMD ["nginx"]
```</p>

<p>Run <code>$ docker build -t demo/kibana3 .</code> to build your application.</p>

<p>It will add the local files ( <code>solo.rb</code>, <code>solo.json</code>, <code>Berksfile</code> ) to /chef in the server and then call berkshelf to download the cookbooks and chef-solo to install your application.   Finally it will give <code>nginx</code> a directive to run in the foreground so that we don't have to do any sneaky prcess control to get it to work with the way <code>docker.io</code> runs processes.</p>

<p>To run the resultant <code>docker.io</code> container you simply need to run <code>$ docker run -d -p 80 demo/kibana3</code></p>
]]></content>
  </entry>
  
</feed>
